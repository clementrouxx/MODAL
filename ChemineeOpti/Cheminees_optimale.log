-- FreeFem++ v4.11 (Thu, Apr 07, 2022  2:25:37 PM - git v4.11)
   file : C:\Users\clemr\OneDrive\Bureau\travail\2A\MODAL\Cheminees_optimale.edp
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue
    1 : load "iovtk"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\iovtk = 0) load: iovtk
;
    2 : int[int] fforder=[1];
    3 :
    4 :
    5 :
    6 : real w=0.8*pi; // frequence de travail
    7 : real l=pi/w, ell=1, h=1, d = 4; //parametres de la geometrie
    8 :
    9 : int m=30; //nombre de mailles par element de longueur
   10 : int maxSteps = 30; // Nombre maximal d'étapes dans la boucle
   11 : real mu = 1e-4;
   12 :
   13 : real [int] tau(2);
   14 : real [int] tauPrec(2);// tau au tour précédent
   15 : tau(0) = 0;
   16 : tau(1) = 0;
   17 :
   18 : func real sqrdist(real [int] tau1, real [int] tau2){ // Distance euclidienne au carré dans R2
   19 :         return ((tau1(0)-tau2(0))^2 + (tau1(1)-tau2(1))^2);
   20 : }
   21 :
   22 : border a(t=-d,d){x =t; y = -1; label = 1;} //bord du bas
   23 : border b(t=0,1){x =d; y = -1+t; label = 2;} //DROIT : 2
   24 : border hd(t=d,l/2){x =t; y = 0; label = 3;} //bord du haut 3
   25 : border hg(t=-l/2,-d){x =t; y = 0; label = 3;} //bord du haut 3
   26 : border i(t=0,-1){x =-d; y = t; label = 4;} //GAUCHE : 4
   27 :
   28 :
   29 :
   30 :
   31 : real L = 1.34; // L optimal trouvé 'à la main'
   32 :
   33 : border chemG(t=L,0){x=-l/2;y=t;label=3;}
   34 : border chemH(t=-l/2,l/2){x =-t; y = L; label = 3;}
   35 : border chemD(t=0,L){x=l/2;y=t;label=3;}
   36 :
   37 : // border Cercle(t=0,2*pi){ x=0.3*cos(t); y=0.5+0.3*sin(t); label = 1;}
   38 : //plot(a(2*d*m)+b(m)+hd(m*(d-L))+chemD(m*L)+chemH(m*l)+chemG(m*L)+hg(m*(d-L))+i(m), wait = true);
   39 : mesh Th=buildmesh(a(2*d*m)+b(m)+hd(m*(d-l/2))+chemD(m*L)+chemH(m*l)+chemG(m*L)+hg(m*(d-l/2))+i(m));
   40 : //plot(Th,wait=1,cmm="Appuyer sur Enter pour poursuivre");
   41 :
   42 : fespace Vh(Th,P2); // espace elements finis (ici fonctions continues P2 sur chaque triangle)s
   43 :
   44 : func  uifonc=exp(1i*w*x);
   45 : func  uifoncConj=exp(-1i*w*x);
   46 :
   47 : //DEBUT DE LA PARTIE A NE PAS MODIFIER
   48 : /*****************************************
   49 : Construction des Dirichlet-to-Neumann
   50 : ******************************************/
   51 : int nbfpro = 15; //troncature dans le Dirichlet-to-Neumann
   52 : //fonction de la base de fourier
   53 : func complex expin(real x1,real x2, int n)
   54 : {
   55 :         if (n==0)
   56 :         return 1.;
   57 :         else
   58 :         return (sqrt(2.)*cos(n*pi*x2));
   59 : }
   60 : /******************************************************
   61 : Dirichlet-to-Neumann à gauche
   62 : /*****************************************************/
   63 : complex[int,int] vDtNG( Vh.ndof, nbfpro);
   64 : matrix<complex> DtNG;
   65 : for (int n=0;n<nbfpro;n++)
   66 : {
   67 :         func f= expin(x,y,n);
   68 :         varf FiniFourier(u,v) = int1d(Th,4)(v*f); // integration sur le bord gauche
   69 :         complex[int] temp = FiniFourier(0,Vh);
   70 :         vDtNG(:,n)=temp;
   71 : }
   72 : DtNG=vDtNG;
   73 : // Construction de la matrice diagonale pour construire les EFL
   74 : matrix<complex> DG;
   75 : complex[int] diagofDG(nbfpro);
   76 : for (int n =0;n<nbfpro;n++)
   77 : {
   78 :         if (n==0)
   79 :         diagofDG[n] = -1i*w; // moins car dans la formu. varia., il y a un moins
   80 :         else
   81 :         diagofDG[n] = sqrt((n*pi)^2-w^2); // moins car dans la formu. varia., il y a un moins
   82 : }
   83 : DG = [diagofDG];
   84 : // Assemblage final et réorganisation pour intégration dans la formulation variationnelle
   85 : matrix<complex> EFLG ;
   86 : EFLG = DtNG*DG;
   87 : EFLG= EFLG*DtNG';
   88 :
   89 : /******************************************************
   90 : Dirichlet-to-Neumann à droite
   91 : /*****************************************************/
   92 : complex[int,int] vDtND( Vh.ndof, nbfpro);
   93 : matrix<complex> DtND;
   94 : for (int n=0;n<nbfpro;n++)
   95 : {
   96 :         func f= expin(x,y,n);
   97 :         varf FiniFourier(u,v) = int1d(Th,2)(v*f); // integration sur le bord droit
   98 :         complex[int] temp = FiniFourier(0,Vh);
   99 :         vDtND(:,n)=temp;
  100 : }
  101 : DtND=vDtND;
  102 : matrix<complex> DD;
  103 : complex[int] diagofDD(nbfpro);
  104 : for (int n =0;n<nbfpro;n++)
  105 : {
  106 :         if (n==0)
  107 :         diagofDD[n] = -1i*w;
  108 :         else
  109 :         diagofDD[n] = sqrt((n*pi)^2-w^2);
  110 : }
  111 : DD = [diagofDD];
  112 : matrix<complex> EFLD ;
  113 : EFLD = DtND*DD;
  114 : EFLD= EFLD*DtND';
  115 : // FIN DE LA PARTIE A NE PAS MODIFIER
  116 :
  117 : /***************************************
  118 : On passe à la formulation variationnelle
  119 : ****************************************/
  120 : Vh<complex> u,v,ui=uifonc;
  121 : matrix<complex> A,B,C;
  122 : complex[int] G(Vh.ndof);
  123 : cout << "ndof " << Vh.ndof << endl;
  124 : varf aForme(u,v) = int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v))-int2d(Th)(w^2*u*v);
  125 : varf gForme(u,v) =  int1d(Th,4)(-2*1i*w*uifonc*v);
  126 : A= aForme(Vh,Vh);
  127 : C= A+EFLG+EFLD; //on rajoute les Dirichlet-to-Neumann
  128 : set(C,solver=UMFPACK);
  129 : G= gForme(0,Vh);
  130 : u[]=C^-1*G;
  131 : complex R = int1d(Th,4)((u-uifonc)*uifonc);
  132 : complex T = int1d(Th,2)(u*uifoncConj);
  133 :
  134 : Vh uReel=real(u);
  135 : Vh uImag=imag(u);
  136 : plot(uReel,fill=1,dim=2,nbiso=40,value=1,wait=0,cmm="Re u, |R| = "+abs(R)+", T = "+T+", Phase de T : "+atan(imag(T)/real(T)));
  137 :
  138 : Vh uiReel = real(ui);
  139 : Vh uiImag = imag(ui);
  140 :
  141 :
  142 : // Génération de vidéo
  143 : Vh solApprochTempo;
  144 : Vh solApprochTempoInc;
  145 : real Tper=2*pi/w;
  146 : int nbIter=25;
  147 : int j=0;
  148 : int numImage;
  149 : for(real t=0;t<Tper;t+=Tper/nbIter){
  150 :         numImage=1000000+j;
  151 :         solApprochTempo=uReel*cos(w*t)+uImag*sin(w*t);
  152 :         solApprochTempoInc=uiReel*cos(w*t)+uiImag*sin(w*t);
  153 :         savevtk("dataVTK/image"+numImage+".vtk",Th,solApprochTempo,order=fforder,dataname="solution");
  154 :         savevtk("dataVTKinc/image"+numImage+".vtk",Th,solApprochTempoInc,order=fforder,dataname="solution");
  155 :         j++;
  156 : } sizestack + 1024 =5712  ( 4688 )
 
  --  mesh:  Nb of Triangles =  19225, Nb of Vertices 9923
  -- Raw Matrix    nxm  =15x15 nb  none zero coef. 15
  -- Raw Matrix    nxm  =15x15 nb  none zero coef. 15
ndof 39070
 0x283ab5be360 VTK_FILE 1
 0x283ab5be360 VTK_FILE 1
 0x283ab5be090 VTK_FILE 1
 0x283ab5bd910 VTK_FILE 1
 0x283ab5bdca0 VTK_FILE 1
 0x283ab5bdc70 VTK_FILE 1
 0x283ab5be360 VTK_FILE 1
 0x283ab5bde50 VTK_FILE 1
 0x283ab5bd790 VTK_FILE 1
 0x283ab5bd880 VTK_FILE 1
 0x283ab5be360 VTK_FILE 1
 0x283ab5bd940 VTK_FILE 1
 0x283ab5bdbb0 VTK_FILE 1
 0x283ab5bd7f0 VTK_FILE 1
 0x283ab5be150 VTK_FILE 1
 0x283ab5be090 VTK_FILE 1
 0x283ab5bdf10 VTK_FILE 1
 0x283ab5bd820 VTK_FILE 1
 0x283ab5bdc70 VTK_FILE 1
 0x283ab5be240 VTK_FILE 1
 0x283ab5bdaf0 VTK_FILE 1
 0x283ab5be0f0 VTK_FILE 1
 0x283ab5bdca0 VTK_FILE 1
 0x283ab5bdf10 VTK_FILE 1
 0x283ab5be090 VTK_FILE 1
 0x283ab5bd8e0 VTK_FILE 1
 0x283ab5bdcd0 VTK_FILE 1
 0x283ab5bd8e0 VTK_FILE 1
 0x283ab5bdc70 VTK_FILE 1
 0x283ab5bd7f0 VTK_FILE 1
 0x283ab5be240 VTK_FILE 1
 0x283ab5be240 VTK_FILE 1
 0x283ab5bdd30 VTK_FILE 1
 0x283ab5bdc70 VTK_FILE 1
 0x283ab5bda30 VTK_FILE 1
 0x283ab5be120 VTK_FILE 1
 0x283ab5bdfd0 VTK_FILE 1
 0x283ab5bdeb0 VTK_FILE 1
 0x283ab5bdeb0 VTK_FILE 1
 0x283ab5bda00 VTK_FILE 1
 0x283ab5be090 VTK_FILE 1
 0x283ab5bdca0 VTK_FILE 1
 0x283ab5bde50 VTK_FILE 1
 0x283ab5bdbb0 VTK_FILE 1
 0x283ab5bd790 VTK_FILE 1
 0x283ab5bdc70 VTK_FILE 1
 0x283ab5bdcd0 VTK_FILE 1
 0x283ab5bdcd0 VTK_FILE 1
 0x283ab5bdeb0 VTK_FILE 1
 0x283ab5bd8e0 VTK_FILE 1
times: compile 0.246s, execution 4.482s,  mpirank:0
 ######## We forget of deleting   12689 Nb pointer,   0Bytes  ,  mpirank 0, memory leak =0
 CodeAlloc : nb ptr  4592,  size :536648 mpirank: 0
Ok: Normal End
 try getConsole C:\Users\clemr\OneDrive\Bureau\travail\2A\MODAL\Cheminees_optimale.edp
